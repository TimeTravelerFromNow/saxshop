import{rectToClientRect as t,detectOverflow as e,offset as n,autoPlacement as o,shift as i,flip as s,size as c,hide as r,arrow as l,inline as f,limitShift as a,computePosition as u}from"@floating-ui/core";import{round as g,createCoords as h,max as d,min as p,floor as m}from"@floating-ui/utils";import{getComputedStyle as w,isHTMLElement as x,isElement as y,getWindow as R,isWebKit as v,getDocumentElement as C,getNodeName as T,isOverflowElement as O,getNodeScroll as b,getParentNode as L,isLastTraversableNode as P,getOverflowAncestors as B,isContainingBlock as E,isTableElement as S,getContainingBlock as A}from"@floating-ui/utils/dom";export{getOverflowAncestors}from"@floating-ui/utils/dom";function getCssDimensions(t){const e=w(t);let n=parseFloat(e.width)||0;let o=parseFloat(e.height)||0;const i=x(t);const s=i?t.offsetWidth:n;const c=i?t.offsetHeight:o;const r=g(n)!==s||g(o)!==c;if(r){n=s;o=c}return{width:n,height:o,$:r}}function unwrapElement(t){return y(t)?t:t.contextElement}function getScale(t){const e=unwrapElement(t);if(!x(e))return h(1);const n=e.getBoundingClientRect();const{width:o,height:i,$:s}=getCssDimensions(e);let c=(s?g(n.width):n.width)/o;let r=(s?g(n.height):n.height)/i;c&&Number.isFinite(c)||(c=1);r&&Number.isFinite(r)||(r=1);return{x:c,y:r}}const F=h(0);function getVisualOffsets(t){const e=R(t);return v()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:F}function shouldAddVisualOffsets(t,e,n){e===void 0&&(e=false);return!(!n||e&&n!==R(t))&&e}function getBoundingClientRect(e,n,o,i){n===void 0&&(n=false);o===void 0&&(o=false);const s=e.getBoundingClientRect();const c=unwrapElement(e);let r=h(1);n&&(i?y(i)&&(r=getScale(i)):r=getScale(e));const l=shouldAddVisualOffsets(c,o,i)?getVisualOffsets(c):h(0);let f=(s.left+l.x)/r.x;let a=(s.top+l.y)/r.y;let u=s.width/r.x;let g=s.height/r.y;if(c){const t=R(c);const e=i&&y(i)?R(i):i;let n=t;let o=n.frameElement;while(o&&i&&e!==n){const t=getScale(o);const e=o.getBoundingClientRect();const i=w(o);const s=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x;const c=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;f*=t.x;a*=t.y;u*=t.x;g*=t.y;f+=s;a+=c;n=R(o);o=n.frameElement}}return t({width:u,height:g,x:f,y:a})}const V=[":popover-open",":modal"];function isTopLayer(t){return V.some((e=>{try{return t.matches(e)}catch(t){return false}}))}function convertOffsetParentRelativeRectToViewportRelativeRect(t){let{elements:e,rect:n,offsetParent:o,strategy:i}=t;const s=i==="fixed";const c=C(o);const r=!!e&&isTopLayer(e.floating);if(o===c||r&&s)return n;let l={scrollLeft:0,scrollTop:0};let f=h(1);const a=h(0);const u=x(o);if(u||!u&&!s){(T(o)!=="body"||O(c))&&(l=b(o));if(x(o)){const t=getBoundingClientRect(o);f=getScale(o);a.x=t.x+o.clientLeft;a.y=t.y+o.clientTop}}return{width:n.width*f.x,height:n.height*f.y,x:n.x*f.x-l.scrollLeft*f.x+a.x,y:n.y*f.y-l.scrollTop*f.y+a.y}}function getClientRects(t){return Array.from(t.getClientRects())}function getWindowScrollBarX(t){return getBoundingClientRect(C(t)).left+b(t).scrollLeft}function getDocumentRect(t){const e=C(t);const n=b(t);const o=t.ownerDocument.body;const i=d(e.scrollWidth,e.clientWidth,o.scrollWidth,o.clientWidth);const s=d(e.scrollHeight,e.clientHeight,o.scrollHeight,o.clientHeight);let c=-n.scrollLeft+getWindowScrollBarX(t);const r=-n.scrollTop;w(o).direction==="rtl"&&(c+=d(e.clientWidth,o.clientWidth)-i);return{width:i,height:s,x:c,y:r}}function getViewportRect(t,e){const n=R(t);const o=C(t);const i=n.visualViewport;let s=o.clientWidth;let c=o.clientHeight;let r=0;let l=0;if(i){s=i.width;c=i.height;const t=v();if(!t||t&&e==="fixed"){r=i.offsetLeft;l=i.offsetTop}}return{width:s,height:c,x:r,y:l}}function getInnerBoundingClientRect(t,e){const n=getBoundingClientRect(t,true,e==="fixed");const o=n.top+t.clientTop;const i=n.left+t.clientLeft;const s=x(t)?getScale(t):h(1);const c=t.clientWidth*s.x;const r=t.clientHeight*s.y;const l=i*s.x;const f=o*s.y;return{width:c,height:r,x:l,y:f}}function getClientRectFromClippingAncestor(e,n,o){let i;if(n==="viewport")i=getViewportRect(e,o);else if(n==="document")i=getDocumentRect(C(e));else if(y(n))i=getInnerBoundingClientRect(n,o);else{const t=getVisualOffsets(e);i={...n,x:n.x-t.x,y:n.y-t.y}}return t(i)}function hasFixedPositionAncestor(t,e){const n=L(t);return!(n===e||!y(n)||P(n))&&(w(n).position==="fixed"||hasFixedPositionAncestor(n,e))}function getClippingElementAncestors(t,e){const n=e.get(t);if(n)return n;let o=B(t,[],false).filter((t=>y(t)&&T(t)!=="body"));let i=null;const s=w(t).position==="fixed";let c=s?L(t):t;while(y(c)&&!P(c)){const e=w(c);const n=E(c);n||e.position!=="fixed"||(i=null);const r=s?!n&&!i:!n&&e.position==="static"&&!!i&&["absolute","fixed"].includes(i.position)||O(c)&&!n&&hasFixedPositionAncestor(t,c);r?o=o.filter((t=>t!==c)):i=e;c=L(c)}e.set(t,o);return o}function getClippingRect(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const s=n==="clippingAncestors"?isTopLayer(e)?[]:getClippingElementAncestors(e,this._c):[].concat(n);const c=[...s,o];const r=c[0];const l=c.reduce(((t,n)=>{const o=getClientRectFromClippingAncestor(e,n,i);t.top=d(o.top,t.top);t.right=p(o.right,t.right);t.bottom=p(o.bottom,t.bottom);t.left=d(o.left,t.left);return t}),getClientRectFromClippingAncestor(e,r,i));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function getDimensions(t){const{width:e,height:n}=getCssDimensions(t);return{width:e,height:n}}function getRectRelativeToOffsetParent(t,e,n){const o=x(e);const i=C(e);const s=n==="fixed";const c=getBoundingClientRect(t,true,s,e);let r={scrollLeft:0,scrollTop:0};const l=h(0);if(o||!o&&!s){(T(e)!=="body"||O(i))&&(r=b(e));if(o){const t=getBoundingClientRect(e,true,s,e);l.x=t.x+e.clientLeft;l.y=t.y+e.clientTop}else i&&(l.x=getWindowScrollBarX(i))}const f=c.left+r.scrollLeft-l.x;const a=c.top+r.scrollTop-l.y;return{x:f,y:a,width:c.width,height:c.height}}function isStaticPositioned(t){return w(t).position==="static"}function getTrueOffsetParent(t,e){return x(t)&&w(t).position!=="fixed"?e?e(t):t.offsetParent:null}function getOffsetParent(t,e){const n=R(t);if(isTopLayer(t))return n;if(!x(t)){let e=L(t);while(e&&!P(e)){if(y(e)&&!isStaticPositioned(e))return e;e=L(e)}return n}let o=getTrueOffsetParent(t,e);while(o&&S(o)&&isStaticPositioned(o))o=getTrueOffsetParent(o,e);return o&&P(o)&&isStaticPositioned(o)&&!E(o)?n:o||A(t)||n}const getElementRects=async function(t){const e=this.getOffsetParent||getOffsetParent;const n=this.getDimensions;const o=await n(t.floating);return{reference:getRectRelativeToOffsetParent(t.reference,await e(t.floating),t.strategy),floating:{x:0,y:0,width:o.width,height:o.height}}};function isRTL(t){return w(t).direction==="rtl"}const W={convertOffsetParentRelativeRectToViewportRelativeRect:convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement:C,getClippingRect:getClippingRect,getOffsetParent:getOffsetParent,getElementRects:getElementRects,getClientRects:getClientRects,getDimensions:getDimensions,getScale:getScale,isElement:y,isRTL:isRTL};function observeMove(t,e){let n=null;let o;const i=C(t);function cleanup(){var t;clearTimeout(o);(t=n)==null||t.disconnect();n=null}function refresh(s,c){s===void 0&&(s=false);c===void 0&&(c=1);cleanup();const{left:r,top:l,width:f,height:a}=t.getBoundingClientRect();s||e();if(!f||!a)return;const u=m(l);const g=m(i.clientWidth-(r+f));const h=m(i.clientHeight-(l+a));const w=m(r);const x=-u+"px "+-g+"px "+-h+"px "+-w+"px";const y={rootMargin:x,threshold:d(0,p(1,c))||1};let R=true;function handleObserve(t){const e=t[0].intersectionRatio;if(e!==c){if(!R)return refresh();e?refresh(false,e):o=setTimeout((()=>{refresh(false,1e-7)}),1e3)}R=false}try{n=new IntersectionObserver(handleObserve,{...y,root:i.ownerDocument})}catch(t){n=new IntersectionObserver(handleObserve,y)}n.observe(t)}refresh(true);return cleanup}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */function autoUpdate(t,e,n,o){o===void 0&&(o={});const{ancestorScroll:i=true,ancestorResize:s=true,elementResize:c=typeof ResizeObserver==="function",layoutShift:r=typeof IntersectionObserver==="function",animationFrame:l=false}=o;const f=unwrapElement(t);const a=i||s?[...f?B(f):[],...B(e)]:[];a.forEach((t=>{i&&t.addEventListener("scroll",n,{passive:true});s&&t.addEventListener("resize",n)}));const u=f&&r?observeMove(f,n):null;let g=-1;let h=null;if(c){h=new ResizeObserver((t=>{let[o]=t;if(o&&o.target===f&&h){h.unobserve(e);cancelAnimationFrame(g);g=requestAnimationFrame((()=>{var t;(t=h)==null||t.observe(e)}))}n()}));f&&!l&&h.observe(f);h.observe(e)}let d;let p=l?getBoundingClientRect(t):null;l&&frameLoop();function frameLoop(){const e=getBoundingClientRect(t);!p||e.x===p.x&&e.y===p.y&&e.width===p.width&&e.height===p.height||n();p=e;d=requestAnimationFrame(frameLoop)}n();return()=>{var t;a.forEach((t=>{i&&t.removeEventListener("scroll",n);s&&t.removeEventListener("resize",n)}));u==null||u();(t=h)==null||t.disconnect();h=null;l&&cancelAnimationFrame(d)}}const D=e;const H=n;const z=o;const I=i;const M=s;const X=c;const q=r;const N=l;const U=f;const $=a;const computePosition=(t,e,n)=>{const o=new Map;const i={platform:W,...n};const s={...i.platform,_c:o};return u(t,e,{...i,platform:s})};export{N as arrow,z as autoPlacement,autoUpdate,computePosition,D as detectOverflow,M as flip,q as hide,U as inline,$ as limitShift,H as offset,W as platform,I as shift,X as size};

